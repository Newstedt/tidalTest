import pandas as pd
import numpy as np
from matplotlib import pyplot as plt

click_search_df = pd.read_csv('tidal_data_analyst_test/click_search.csv', header=0)
initiate_search_df = pd.read_csv('tidal_data_analyst_test/initiate_search.csv', header=0)
search_query_df = pd.read_csv('tidal_data_analyst_test/search_query.csv', header=0)
search_result_df = pd.read_csv('tidal_data_analyst_test/search_result.csv', header=0)
user_metadata_df = pd.read_csv('tidal_data_analyst_test/user_metadata.csv', header=0)

def main():

    print('Metrics are printed after figures. \n \n')
    numSessWithRes = getNumSessWithRes()
    numSessClickPerUser = getNumSessClickPerUser()
    distClickContType = getDistClickContType() #plot commented out
    meanQueryLen = getMeanLenQueries()
    ctrPerPlat, clicksPerRes, clicksPerSearch, searchWithClick = getCTR()
    nrTopResClicks = getNrTopResClicks()
    nrSessWithEmptyQueryRes = getNrSessWithEmptyQueryRes()
    meanTimeToClick, medianTimeToClick = getTimeToClick()
    deltaTimeFunction()

    print('Number of search sessions with a result is: ', numSessWithRes, '\n')
    print('Number of search sessions with one or more clicks per user: ', numSessClickPerUser, '\n')
    print('Distribution of clicks: \n', distClickContType, '\n')
    print('Average query length: ', meanQueryLen, '\n')
    print('CTR (Number of clicks per unique search ID) per platform: \n', ctrPerPlat, '\n')
    print('Number of clicks per query result: ', clicksPerRes, '\n')
    print('Number of clicks per search query: ', clicksPerSearch, '\n')
    print('How often a search generates one or more clicks: ', searchWithClick, '\n')
    print('Number of clicks on top result: ', nrTopResClicks, '\n')
    print('Number of search sessions that contained one or more queries that gave empty results: ',
          nrSessWithEmptyQueryRes, '\n')
    print('Mean time - search to click: ', meanTimeToClick)
    print('Median time - search to click: ', medianTimeToClick, '\n')


def getNumSessWithRes():
    # Number of search sessions with a result - Check how many unique search queries that has one or more results
    numResUniqueSearchId = search_result_df['searchUuid'].nunique()
    return numResUniqueSearchId

def getNumSessClickPerUser():
    # Number of search sessions with one or more clicks per user
    numSessWithClick = click_search_df['searchUuid'].nunique()
    return numSessWithClick/(user_metadata_df['user_id'].nunique())

def getDistClickContType():
    # Distribution of clicks by content type
    contTypeGroup = click_search_df.groupby('contentType').size()
    distClickContType = contTypeGroup.div(contTypeGroup.sum()).multiply(100)

    plotFunc(distClickContType, distClickContType.axes[0], 'Distribution of clicks by content type',True)

    return distClickContType

def getMeanLenQueries():
    # Find mean length of queries. only consider unique queryUuids
    searchResNoQueIdDups = search_result_df.drop_duplicates(subset='queryUuid')
    queryLens = searchResNoQueIdDups['query'].str.len()
    return queryLens.mean()

def getNrTopResClicks():

    # Number of clicks on top result
    nrTopResClicks = click_search_df[click_search_df['moduleId'] == 'search_topresult'].shape[0]

    # Top-click distrubition per platform
    contTypeTop = click_search_df[click_search_df['moduleId'] == 'search_topresult'].groupby('client_platform').size()
    distContTypeTop = contTypeTop.div(contTypeTop.sum()).multiply(100)

    plotFunc(distContTypeTop,distContTypeTop.axes[0],'Distribution of Top-result clicks', True)

    return nrTopResClicks


def getCTR():

    resUniqSearchID = search_result_df.drop_duplicates(subset='searchUuid')
    clickUniqSearchID = click_search_df['searchUuid'].drop_duplicates()

    # Number of clicks per query result
    clicksPerRes = click_search_df['searchUuid'].shape[0]/search_result_df['searchUuid'].shape[0]

    # Number of clicks per search query
    clicksPerSearch = click_search_df['searchUuid'].shape[0]/resUniqSearchID.shape[0]

    # How often a search generates one or more clicks
    searchWithClick = clickUniqSearchID.shape[0]/resUniqSearchID.shape[0]

    # CTR per platform
    searchPerPlat = resUniqSearchID.groupby('client_platform')
    clickPerPlat = click_search_df.groupby('client_platform')

    # How I define CTR: Number of clicks generated by a user search
    CTRPerPlat = pd.DataFrame()
    for name, group in searchPerPlat:
        temp = pd.DataFrame({'client_platform': [name], 'ratio': [clickPerPlat.groups[name].shape[0]/group.shape[0]]})
        CTRPerPlat = CTRPerPlat.append(temp)

    CTRPerPlat.plot.bar(x='client_platform', y='ratio', rot=0)
    plt.title('CTR per Client Platform')
    plt.xlabel('Client Platform')
    plt.ylabel('CTR')
    plt.show()

    return CTRPerPlat, clicksPerRes, clicksPerSearch, searchWithClick

def getNrSessWithEmptyQueryRes():
    # Number of search sessions that contained one or more queries that gave empty results
    sessGroups = search_result_df.groupby('searchUuid')
    emptyResults = search_query_df.loc[((search_query_df['artistResults'] == '[]') &
                                        (search_query_df['trackResults'] == '[]') &
                                        (search_query_df['albumResults'] == '[]') &
                                        (search_query_df['videoResults'] == '[]'))]

    usersWithEmptyRes = user_metadata_df[user_metadata_df['user_id'].isin(emptyResults['user_id']) == True]

    emptyResPerSubType = usersWithEmptyRes.groupby('subscriptionType').size()
    emptyResPerGender = usersWithEmptyRes.groupby('gender').size()
    emptyResPerCountry = usersWithEmptyRes.groupby('countryCode').size()
    emptyResPerChurned = usersWithEmptyRes.groupby('churned').size()

    # Look at three most contributing countries and group others
    plotCountry = emptyResPerCountry.nlargest(3)
    others = pd.Series({'Others' : emptyResPerCountry.nsmallest(emptyResPerCountry.shape[0]-3).sum()})
    plotCountry = plotCountry.append(others)

    plotFunc(emptyResPerSubType, user_metadata_df['subscriptionType'].axes[0],'Empty Results by subscriptiontype',False)
    plotFunc(emptyResPerGender, user_metadata_df['gender'].axes[0],'Empty results by gender',False)
    plotFunc(plotCountry, plotCountry.axes[0],'Empty result by Country',False)
    plotFunc(emptyResPerChurned, user_metadata_df['churned'].axes[0],'Empty result by churned',False)

    sessWithEmptyRes = 0
    for name, group in sessGroups:
        if group['queryUuid'].isin(emptyResults['queryUuid']).any():
            sessWithEmptyRes += 1

    return sessWithEmptyRes

def deltaTimeFunction():
    # count number of search results per hour
    tStart = np.sort(search_result_df['server_ts'])[0]
    tEnd = np.sort(search_result_df['server_ts'])[-1]
    dt = 3600
    t = tStart
    searchPerHour = []
    while t < tEnd:
        tRange = np.array(range(t, t + dt))
        searchPerHour.append(search_result_df[search_result_df['server_ts'].isin(tRange) == True].shape[0])
        t += dt

    testit = pd.DataFrame({'spm': searchPerHour})
    plt.plot(testit.rolling(window=3).mean())
    plt.title('Moving average (lag = 3): number of search per hour')
    plt.xlabel('time')
    plt.ylabel('search per hour')
    plt.show()
    return searchPerHour

def getTimeToClick():

    firstInitPerSearch = initiate_search_df.sort_values(by='event_ts').drop_duplicates(subset='searchUuid', keep='first')
    firstClickPerSearch = click_search_df.sort_values(by='event_ts').drop_duplicates(subset='searchUuid', keep='first')

    T1s = firstInitPerSearch[firstInitPerSearch['searchUuid'].isin(firstClickPerSearch['searchUuid']) == True].sort_values(by='searchUuid')
    T2s = firstClickPerSearch[firstClickPerSearch['searchUuid'].isin(firstInitPerSearch['searchUuid']) == True].sort_values(by='searchUuid')

    dTs = T2s['event_ts'].values - T1s['event_ts'].values

    # Mean and Median time to click in Seconds
    meanTimeToClick = 1e-3*np.mean(dTs)
    medianTimeToClick = 1e-3*np.median(dTs)
    return meanTimeToClick, medianTimeToClick

def plotFunc(sizes,labels,title,percentInLabel):
    sizes.plot(kind='pie', autopct='%1.1f%%', startangle=90, shadow=False, fontsize=8)
    plt.subplots_adjust(left=0.1, bottom=0.1, right=0.45)
    plt.title(title).set_ha("left")
    plt.gca().axis("equal")
    plt.ylabel('')
    if percentInLabel == True:
        plt.legend(labels=['%s, %1.1f %%' % (l, s) for l, s in zip(labels, sizes)],bbox_to_anchor=(0.9,0.5),
                   loc="center right", fontsize=10, bbox_transform=plt.gcf().transFigure)
    else:
        plt.legend(bbox_to_anchor=(0.9,0.5), loc="center right", fontsize=10, bbox_transform=plt.gcf().transFigure)
    plt.show()
    
    return


if __name__ == "__main__":
    main()